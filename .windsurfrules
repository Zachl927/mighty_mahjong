# Windsurf Rules
As a senior game developer specializing in the Godot, GDScript, ENet, and SQLite stack, I’ve crafted the following set of 10 rules to guide the development of *might_mahjong*, a multiplayer game. These rules ensure efficient development, robust networking, and a maintainable codebase, with a specific emphasis on modularity to avoid a monolithic structure.
---

### 1. **Leverage ENet’s Packet Transmission Features**
   - Use ENet’s **reliable transmission** for critical game state updates (e.g., score changes or game events) to ensure data consistency across players.
   - Use **unreliable transmission** for real-time, non-critical data (e.g., player positions or animations) to reduce latency and maintain responsiveness.

---

### 2. **Avoid a Monolithic Codebase Through Modularity**
   - Structure the game using **multiple GDScript files and Godot scenes**, each responsible for a specific component (e.g., player management, game logic, UI, networking).
   - This modular design prevents a single, unwieldy script, improving maintainability, scalability, and ease of debugging.

---

### 3. **Handle Database Operations Asynchronously**
   - Perform SQLite operations (e.g., saving player progress or settings) **asynchronously** using Godot’s threading capabilities.
   - This keeps the main thread unblocked, ensuring the game remains smooth and responsive during database interactions.

---

### 4. **Implement Robust Networking Error Handling**
   - Include **comprehensive error handling** for network operations, such as dropped connections or timeouts.
   - Provide players with **clear feedback** (e.g., “Connection lost, attempting to reconnect”) and implement recovery mechanisms to enhance the multiplayer experience.

---

### 5. **Optimize Performance Proactively**
   - Minimize the number of objects and scripts processed per frame to reduce performance overhead.
   - Utilize Godot’s **profiler and optimization tools** to identify and address bottlenecks, ensuring smooth gameplay in multiplayer scenarios.

---

### 6. **Design a Modular and Reusable UI**
   - Build the user interface with Godot’s **UI nodes and signals**, creating modular, reusable components (e.g., buttons, score displays).
   - This ensures the UI is responsive and adaptable across different game states or modes.

---

### 7. **Organize Assets and Logic with Godot’s Scene System**
   - Use Godot’s **scene system** to encapsulate distinct parts of the game (e.g., levels, menus, player entities).
   - Each scene should be self-contained, promoting organization and reusability of assets and logic.

---

### 8. **Manage Game States with a State Machine**
   - Implement a **state machine** to handle game phases (e.g., lobby, in-game, post-game).
   - This organizes the codebase and simplifies transitions between different states.

---

### 9. **Use Signals and Slots for Event Handling**
   - Employ GDScript’s **signals and slots** to facilitate communication between game components (e.g., notifying the UI of a player action).
   - This reduces script dependencies, supporting the modular architecture.

---

### 10. **Test Regularly with Multiple Players**
   - Conduct frequent **multiplayer testing** to validate networking and gameplay functionality.
   - Leverage Godot’s testing tools to automate tests where possible, ensuring reliability in LAN-based multiplayer sessions.

---

These 10 rules provide a comprehensive framework for developing *mighty_mahjong* using the Godot, GDScript, ENet, and SQLite stack. Rule 2 explicitly emphasizes modularity by advocating for multiple files and scenes over a single monolithic script, while the remaining rules address best practices for networking, performance, and architecture tailored to this tech stack and the game’s multiplayer nature.